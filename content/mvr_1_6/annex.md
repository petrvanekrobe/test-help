---
title: "Annex"
description: ""
lead: ""
date: 2023-11-26T14:00:06+0100
lastmod: 2023-11-26T14:00:09+0100
draft: false
images: []
weight: 250
toc: true
---
## Annex A. Object ID for Selection purposes (informative)

In order to control or reference, all objects in the MVR Spec have human
readable object IDs. For this both the FixtureIDNumeric and the CustomId is
used.  The FixtureIDNumeric is a generic name pool that applies to all objects.
All FixtureIDNumerics should be unique in one scene, so that objects can be
selected without collisions.  The CustomId has a similar approach, but allows
you define the pool type for the numbers as well. An object can so report that
it is a Pyro device, and in the Pyro ID Pool it has the number 100.  Normally
FixtureIDs are numeric to allow range selection. For Descriptive display on
plots, some tools also append a letter like # or A before the FixtureID. A lot
of tools have a concept of selecting objects with a range. Like 100 thru 200.
So the Numeric portion of the FixtureID should be placed into the
FixtureIDNumeric field.  A similar concept is the multipatch. Sometimes you
want to group multiple objects behind the same FixtureIDNumeric or CustomId.
This can be objects of the same GDTF Type, but not forced to be. When you
select the FixtureIDNumeric or CustomId from the multipatch parent, all objects
that reference this object in multipatch parent should also be selected.

If the device supports the RDM protocol, the FixtureIDNumeric corresponds to
the RDM PID 0x0656 DEVICE_UNIT_NUMBER.

## Annex B. UUID purposes (informative)

UUIDs are randomly generated numbers which are, practically speaking, unique
and unable to conflict. The way UUIDs are designed is what allows them to
uniquely identify an object with certainty. They are so unique that if you
generate one today, you can be reasonably certain that this UUID has never been
generated before and will never be generated by someone else in the future.
This means that UUIDs in MVR will not conflict even across many files. Because
it is easier to disregard data than try to derive it, MVR requires UUIDs for
many things. This design and its incorporation into MVR is advantageous for
many reasons, a few of which we will discuss below.  One of the most important
aspects of UUIDs in MVR is that they are persistent. A UUID should identify an
item throughout its entire life cycle. This means that if a document is
exported, then objects should have the same UUID every time an export is
performed.  One use case for UUIDs is importing or merging MVRs into an
existing document. This is one reason that persistent UUIDs are valuable. If
you export an MVR from one program, open it in another, and make modifications,
then you may want to incorporate those changes into the original document. By
cross referencing UUIDs, you can avoid creating duplicate objects and instead
update existing ones.  UUIDs are also used inside of the MVR file format as a
form of reference. For example, a symbol instance shall refer to a symbol
definition. Because the symbol definition is given a UUID, the symbol instance
can reference its symbol through the use of this UUID.
